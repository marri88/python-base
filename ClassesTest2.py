# # '''
# # Значение термина «инкапсуляция» расплывчато и отличается от источника к
# # источнику. Принято считать, что инкапсуляция — один из основополагающих
# # принципов ООП, хотя некоторые научные статьи вовсе упускают инкапсуляцию
# # из списка. К примеру, Джон Митчелл в книге «Концепты в языках
# # программирования» при перечислении основных концептов в ООП упоминает
# # только абстракцию — термин который принято считать близким к
# # инкапсуляции по значению, но все-же более обширным и высокоуровневым. С
# # другой стороны, Роберт Мартин в его книге «Чистая архитектура» явно говорит о том, что инкапсуляция, наследование и полиморфизм считается
# # фундаментом ООП.

# # Разнообразие определений, данных термину «инкапсуляция», сложно привести
# # к общему знаменателю. В целом можно выделить два подхода к значению
# # этого термина. 
# # Инкапсуляция может быть рассмотрена как:

# # ● связь данных с методами которые этими данными управляют;
# # ● набор инструментов для управления доступом к данным или
# # методам которые управляют этими данными.
# # '''

# # ####    Инкапсуляция как связь    ######

# # '''
# # Подобного рода трактовка термина «инкапсуляция» очень проста в
# # объяснении. В данном случае, любой класс в котором есть хотя бы одна
# # переменная и один метод который ею управляет наглядно демонстрирует этот
# # принцип.
# # '''


# # class Phone:
# #     number = "111-11-11"

# #     def print_number(self):
# #         print( "Phone number is: ", self.number )

# # my_phone = Phone()
# # my_phone.print_number()

# # '''
# # Можно создать класс, который состоит только из методов (и не содержит
# # переменных), что может быть удобно в некоторых языках программирования.
# # Также возможно создать класс содержащий только данные, без методов, чего,
# # во многих случаях, следует избегать. Обе практики следует применять в случае
# # необходимости и их отношение к «объединяющей» инкапсуляции спорно.
# # '''

# # #####    Инкапсуляция как управление доступом    ######

# # '''
# # Объяснение концепции ограничения доступа к данным или методам требует
# # гораздо большего количества деталей. Прежде всего, в этом контексте термин
# # «доступ» следует понимать как способность видеть и / или изменять
# # внутреннее содержимое класса. Существует несколько уровней доступа,
# # предоставляемых большинством ООП языков. Обобщая можно сказать что
# # данные объекта могут быть:

# # ● публичными (public) — данные доступны всем;

# # ● приватными (private) — данные доступны только объекту/классу
# # которому они принадлежат;


# # #####    Python 3 предоставляет 3 уровня доступа к данным:   ######


# # - публичный (public, нет особого синтаксиса, publicBanana);

# # - защищенный (protected, одно нижнее подчеркивание в начале
# # названия, _protectedBanana);

# # - приватный (private, два нижних подчеркивания в начала названия,
# # __privateBanana).

# # '''
# # Для краткости и простоты, только два базовых уровня (приватный и публичный)
# # освещены в примере.
# # '''

# # class Phone:
# #     username = "Kate" # public variable
# #     __how_many_times_turned_on = 0 # private variable

# #     def call(self): # public method
# #         print( "Ring-ring!" )

# #     def __turn_on(self): # private method
# #         self.__how_many_times_turned_on += 1
# #         print("Times was turned on: ", self.__how_many_times_turned_on)

# # my_phone = Phone()
# # my_phone.call()
# # print("The username is:", my_phone.username)
# # # my_phone.turn_on()
# # print(dir(my_phone))
# # # my_phone.__turn_on()
# # print("Turned on:", my_phone.__how_many_times_turned_on)
# # print( "Turned on: ", my_phone.how_many_times_turned_on)
# # will produce an error



# # #####   Нарушение инкапсуляции    ######

# # '''
# # Сам язык предоставляет программисту синтаксический инструмент, который
# # может обойти инкапсуляцию. Читать и изменять частные переменные и
# # вызывать частные функции все же возможно.
# # '''

# # class Phone:
# #     username = "Kate" # public variable
# #     __serial_number = "11.22.33" # private variable
# #     __how_many_times_turned_on = 0 # private variable

# #     def call(self): # public method
# #         print( "Ring-ring!" )
    
# #     def __turn_on(self): # private method
# #         self.__how_many_times_turned_on += 1
# #         print( "Times was turned on: ", self.__how_many_times_turned_on)


# # my_phone = Phone()
# # my_phone._Phone__turn_on()
# # my_phone._Phone__serial_number = "44.55.66"
# # print( "New serial number is ", my_phone._Phone__serial_number )


# # '''

# # Касательно инкапсуляции непосредственно в языке программирования Python скрыть атрибуты класса можно сделав их приватными или закрытыми и ограничив доступ к ним через специальные методы, которые еще называются свойствами.

# # А попытка получить его значение приведет к ошибке выполнения:
# # '''

# # class Human():
# #     # __private - переменная
# #     __privateVar = "this is __private variable"

# #     def __init__(self):
# #         self.className = "Human class constructor"
# #         self.__privateVar = "this is redefined __private variable"

# #     # public - доступен везде
# #     def showName(self, name):
# #         self.name = name
# #         return self.__privateVar + " " + name

# #     # __private - Доступен только в базовом классе
# #     def __privateMethod(self):
# #         return "Private method"

# #     # _protected - Доступен в классах - наследниках
# #     def _protectedMethod(self):
# #         return "Protected method"

# #     # __private - Доступен ТОЛЬКО из базового класса
# #     def showPrivate(self):
# #         return self.__privateMethod()

# #     def showProtecded(self):
# #         return self._protectedMethod()


# # class Male(Human):
# #     def showClassName(self):
# #         return "Male"

# #     def showPrivate(self):
# #         return self.__privateMethod()

# #     def showProtected(self):
# #         return self._protectedMethod()


# # class Female(Human):
# #     def showClassName(self):
# #         return "Female"

# #     def showPrivate(self):
# #         return self.__privateMethod()

# #     def showProtected(self):
# #         return self._protectedMethod()


# # h = Human()
# # print(h.className)
# # print(h.showName("Vasya"))
# # print(h.showPrivate())
# # print(h.showProtecded())
# # # print(h.privateMethod())
# # # print(h.protectedMethod())
# # print("\n")

# # m = Male()
# # print(m.className)
# # print(m.showClassName())
# # print(m.showPrivate())
# # print(m.showProtected())
# # print("\n")

# # f = Female()
# # print(f.className)
# # print(f.showClassName())
# # print(f.showProtected())
# # print("\n")
















# class Human:
#     #Статические поля
#     default_name = 'No name'
#     default_age = 0

#     def __init__(self, name=default_name, age=default_name):
#         #Динамические поля
#         #Публичные
#         self.name = name
#         self.age = age
#         #Приватные
#         self.__money = 0
#         self.__house = None

#     def info(self):
#         print(f'Name: {self.name}')
#         print(f'Age: {self.age}')
#         print(f'Money: {self.__money}')
#         print(f'House: {self.__house}')

#     # Статический метод
#     @staticmethod
#     def default_info():
#         print(f'Default Name: {Human.default_name}')
#         print(f'Default Age: {Human.default_age}')

#     def earn_money(self, amount):
#         self.__money += amount
#         print(f'Earned {amount} moneu! Current value: {self.__money}')

#     def buy_house(self, house, discount):
#         price = house.final_price(discount)
#         if self.__money >= price:
#             self.__make_deal(house, price)
#         else:
#             print('Not enough money!')


#     # Приватный метод
#     def __make_deal(self, house, price):
#         self.__money = price
#         self.__house = house


# class House:
#     def __init__(self, area, price):
#         self._area = area
#         self._price = price

#     def final_price(self, discount):
#         final_price = self._price * (100 - discount) / 100
#         print(f'Final price: {final_price}')
#         return final_price

# class SmallHouse(House):

#     default_area = 40

#     def __init__(self, price):
#         super().__init__(SmallHouse.default_area, price)

# if __name__ == '__main__':
#     print(Human.default_name)

#     # fedor = Human('Fedor', 32)
#     #
#     # fedor.info()
#     # Human.default_info()
#     #
#     # fedor.earn_money(10000)
#     # fedor.info()
#     #
#     # house = House(100, 15000)
#     # fedor.buy_house(house, 3)

#     Human.default_info()
#     alex = Human('Alex', 20)
#     alex.info()

#     small_house = SmallHouse(8500)
#     alex.buy_house(small_house, 5)

#     alex.earn_money(5000)
#     alex.buy_house(small_house, 5)


#     alex.earn_money(20000)
#     alex.buy_house(small_house, 5)
#     alex.info()





# '''
# Обзор терминологии ООП

#     Класс – определенный пользователем прототип для объекта, который определяет набор атрибутов, которые характеризуют любой объект класса. Атрибуты являются членами данных (переменные класса и переменные экземпляра) и методы, доступ к которым  с помощью запись через точку.
#     Переменная класса – переменная, которая разделяется всеми экземплярами класса. Переменные класса определяются в пределах класса, но не в любом методе класса. Переменные класса не используются так часто, как переменные экземпляра.
#     Элемент данных – класс переменной или экземпляра переменной, которая содержит данные, связанные с классом и его объектами.
#     Перегрузка функций – присвоение более одного поведения определенной функции. Выполняемая операция зависит от типов задействованных объектов или аргументов.
#     Переменная экземпляра – переменная, определенная внутри метода и относится только к текущему экземпляру класса.
#     Наследование – передача характеристик одного класса к другим классам, которые являются производными от него.
#     Экземпляр – индивидуальный объект определенного класса. Объект OBJ, который принадлежит к классу Circle, например, является экземпляром класса Circle.
#     Instantiation – создание экземпляра класса.
#     Метод – особый вид функции, который определяется в определении класса.
#     Объект – уникальный экземпляр структуры данных, который определяется его классом. Объект включает в себя как элементы данных (переменные класса и переменные экземпляра) и методы.
# '''


# '''
# Python поддерживает объектно-ориентированную парадигму программирования, а это значит, что мы можем определить компоненты программы в виде классов.

# Класс является шаблоном или формальным описанием объекта, а объект представляет экземпляр этого класса, его реальное воплощение. Можно провести следующую аналогию: у всех у нас есть некоторое представление о человеке - наличие двух рук, двух ног, головы, пищеварительной, нервной системы, головного мозга и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.

# С точки зрения кода класс объединяет набор функций и переменных, которые выполняют определенную задачу. Функции класса еще называют методами. Они определяют поведение класса. А переменные класса называют атрибутами- они хранят состояние класса

# Класс определяется с помощью ключевого слова class:
# '''


# class название_класса:
#     методы_класса


# '''
# Для создания объекта класса используется следующий синтаксис:
# '''

# название_объекта = название_класса([параметры])

# '''
# Например, определим простейший класс Person, который будет представлять человека:
# '''



# class Person:
#     name = "Aybek"
 
#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
# person1 = Person()
# person1.display_info()         # Привет, меня зовут Aybek
 
# person2 = Person()
# person2.name = "Nursultan"
# person2.display_info()         # Привет, меня зовут Nursultan


# #####     Конструкторы    #####

# '''
# Для создания объекта класса используется конструктор. Так, выше когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию, который неявно имеют все классы:
# '''


# person1 = Person()
# person2 = Person()

# '''
# Однако мы можем явным образом определить в классах конструктор с помощью специального метода, который называется __init(). К примеру, изменим класс Person, добавив в него конструктор:
# '''

# class Person:
 
#     # конструктор
#     def __init__(self, name, surname):
#         self.name = name  # устанавливаем имя
#         self.surname = surname

#     def display_info(self):
#         print("Привет, меня зовут", self.name,  self.surname)
 
# person1 = Person("Aybek", "Sapashov")
# # person1.display_info()         # Привет, меня зовут Aybek
# person2 = Person("Nursultan", "Karpov")
# person2.display_info()         # Привет, меня зовут Nursultan



# '''
# В качестве первого параметра конструктор также принимает ссылку на текущий объект - self. Нередко в конструкторах устанавливаются атрибуты класса. Так, в данном случае в качестве второго параметра в конструктор передается имя пользователя, которое устанавливается для атрибута self.name. Причем для атрибута необязательно определять в классе переменную name, как это было в предыдущей версии класса Person. Установка значения self.name = name уже неявно создает атрибут name.
# '''

# person1 = Person("Tom")
# person2 = Person("Sam", "Jonson")


# ####     Деструктор     #####

# '''
# После окончания работы с объектом мы можем использовать оператор del для удаления его из памяти:
# '''


# person1 = Person("Tom", "Johns")
# del person1     # удаление из памяти
# # person1.display_info()  # Этот метод работать не будет, так как person1 уже удален из памяти
# person2.display_info()

# '''
# Стоит отметить, что в принципе это необязательно делать, так как после окончания работы скрипта все объекты автоматически удаляются из памяти.

# Кроме того, мы можем определить определить в классе деструктор, реализовав встроенную функцию __del__, который будет вызываться либо в результате вызова оператора del, либо при автоматическом удалении объекта. Например:
# '''


# class Person:

#     # конструктор
#     def __init__(self, name):
#         self.name = name  # устанавливаем имя
 
#     def __del__(self):
#         print(self.name,"удален из памяти")

#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
 
# person1 = Person("Aybek")
# person1.display_info()  # Привет, меня зовут Aybek
# del person1     # удаление из памяти
# # person1.display_info()
# person2 = Person("Nursultan")
# person2.display_info()  # Привет, меня зовут Nursultan


# #####    Определение классов в модулях и подключение    ####

# '''
# Как правило, классы размещаются в отдельных модулях и затем уже импортируются в основой скрипт программы. Пусть у нас будет в проекте два файла: файл main.py (основной скрипт программы) и classes.py (скрипт с определением классов).
# '''

# '''
# В дополнение к классу Person здесь также определен класс Auto, который представляет машину и который имеет метод move и атрибут name. Подключим эти классы и используем их в скрипте main.py:
# '''

# from classes import Person, Auto 
 
# tom = Person("Tom")
# tom.display_info()
 
# bmw = Auto("BMW")
# bmw.move(65)


# ######    Аргумент self     ######


# '''
# Рассмотрим зачем нужен и что означает self в функциях Python. Как можно было заметить, единственным атрибутом для метода из класса является ключевое слово self. Помещать его нужно в каждую функцию чтобы иметь возможность вызвать ее на текущем объекте. Также с помощью этого ключевого слова можно получать доступ к полям класса в описываемом методе. Self таким образом заменяет идентификатор объекта.
# '''

# class Dog:
#     name = "Charlie"
#     noise = "Woof!"

#     def makeNoise(self):
#         print(self.name + " says: " + self.noise + " " + self.noise)
    
    
# dog = Dog()
# dog.makeNoise()


# '''
# Вверху представлен класс Dog, описывающий собаку. Он обладает полями name (имя) со стартовым значением «Charlie» и noise (шум), содержащим звук, который издает животное. Метод makeNoise заставляет собаку лаять, выдавая соответствующее сообщение на экран. Для этого в функции print используется получение доступа к полям name и noise. Далее необходимо создать экземпляр класса Dog и вызвать на нем makeNoise.
# '''




# #####    Доступ к атрибутам     #####


# class Employee:
#    'Общий базовый класс для всех сотрудников'
#    empCount = 0

#    def __init__(self, name, salary):
#       self.name = name
#       self.salary = salary
#       Employee.empCount += 1
   
#    def displayCount(self):
#      print ("Всего сотрудников %d" % Employee.empCount)

#    def displayEmployee(self):
#       print ("Имя : ", self.name,  ", Зарплата: ", self.salary)

# empl = Employee("Erjan", 20)
# empl2 = Employee("Myktybek", 15)
# empl.displayCount()
# empl.displayEmployee()
# empl2.displayEmployee()


# '''
# Вы можете получить доступ к атрибутам объекта, используя оператор точка с объектом. Переменная класса получит доступ, используя имя класса следующим образом:
# '''

# emp1.displayEmployee()
# emp2.displayEmployee()
# print ("Всего сотрудников %d" % Employee.empCount)



# #Это создаст первый объект класса сотрудника"
# emp1 = Employee("AndreyEx", 80000)
# #Это позволит создать второй объект класса employee"
# emp2 = Employee("Alex", 65000)
# emp1.displayEmployee()
# emp2.displayEmployee()
# print ("Всего сотрудников %d" % Employee.empCount)


# '''
# Вы можете добавлять, удалять или изменять атрибуты классов и объектов в любое время:
# '''

# emp1.salary = 7000  # Add an 'salary' attribute.
# emp1.name = 'xyz'  # Modify 'age' attribute.
# del emp1.salary  # Delete 'age' attribute.


# '''
# Вместо того, чтобы использовать обычные заявления атрибутов доступа, вы можете использовать следующие функции:

#     GetAttr (объект, имя [, по умолчанию]) – для доступа к атрибуту объекта.
#     Hasattr (объект, имя) – проверить, существует атрибут или нет.
#     SetAttr (объект, имя, значение) – установить атрибут. Если атрибут не существует, то он будет создан.
#     Delattr (объект, имя) – для удаления атрибута.
# '''

# hasattr(emp1, 'salary')    # Возвращает true, если атрибут 'salary' существует
# getattr(emp1, 'salary')    # Возвращает значение атрибута 'salary'
# setattr(emp1, 'salary', 7000) # Устанавливает атрибут 'salary' в 70000
# delattr(emp1, 'salary')    # Удаляет атрибут 'salary'


# #####     Встроенные атрибуты класса    ######


# '''
# Каждый класс Python поддерживает следующие встроенные атрибуты и их можно получить с помощью оператора точки, как и любой другой атрибут:

#     __dict__ – Словарь, содержащий пространство имен класса.
#     __doc__ – Документация класса string или нет, если не определено.
#     __name__ – Имя класса.
#     __module__ – Имя модуля, в котором определен класс. Это атрибут «__main__» в интерактивном режиме.
#     __bases__ – Возможно пустой кортеж, содержащий базовые классы, в порядке их появления в списке базового класса.

# Для приведенного выше класса давайте попробуем открыть все эти атрибуты:
# '''


# class Employee:
#    'Общий базовый класс для всех сотрудников'
#    empCount = 0

#    def __init__(self, name, salary):
#       self.name = name
#       self.salary = salary
#       Employee.empCount += 1
   
#    def displayCount(self):
#      print ("Всего сотрудников %d" % Employee.empCount)

#    def displayEmployee(self):
#       print ("Имя : ", self.name,  ", Зарплата: ", self.salary)

# emp1 = Employee("AndreyEx", 80000)
# emp2 = Employee("Alex", 65000)
# print ("Employee.__doc__:", Employee.__doc__)
# print ("Employee.__name__:", Employee.__name__)
# print ("Employee.__module__:", Employee.__module__)
# print ("Employee.__bases__:", Employee.__bases__)
# print ("Employee.__dict__:", Employee.__dict__ )


# #####     Уничтожение объектов (Garbage Collection)    ######

# '''
# Python удаляет ненужные объекты (встроенные типы или экземпляры классов) автоматически, чтобы освободить место в памяти. Процесс, посредством которого Python периодически восстанавливает блоки памяти, которые больше не находятся в использовании называется как сборщики мусора.

# Сборщик мусора в Python работают во время выполнения программы и срабатывают, когда счетчик ссылок объекта достигает нуля. Счетчик ссылок объекта изменяется, как число псевдонимов, которые указывают на ее изменения.

# Счетчик ссылок объекта увеличивается, когда ему присваивается новое имя или помещается в контейнер (список, кортеж, или словарь). Счетчик ссылок объекта уменьшается, когда он удаляется с del, его ссылка переназначается, или его ссылка выходит из области видимости. Когда счетчик ссылок объекта достигает нуля, Python собирает его автоматически.
# '''

# a = 40      # Создание объекта <40>
# b = a       # Увеличение счетчика ссылок <40> 
# c = [b]     # Увеличение счетчика ссылок <40> 

# del a       # Уменьшение счетчика ссылок <40>
# b = 100     # Уменьшение счетчика ссылок <40> 
# c[0] = -1   # Уменьшение счетчика ссылок <40>


# '''
# Как правило, вы не замечаете, когда сборщик мусора уничтожает обнулившийся экземпляр и высвобождает его пространство. Тем не менее, класс может реализовать специальный метод  __del __(), называется деструктор, который вызывается, когда экземпляр собирается быть уничтоженным. Этот метод может быть использован для очистки любых ресурсов из памяти, используемых экземпляр.
# '''

# '''
# Деструктор __del __ () печатает имя класса экземпляра, который собирается быть уничтожен:
# '''

# class Point:
#    def __init__( self, x=0, y=0):
#       self.x = x
#       self.y = y
#    def __del__(self):
#       class_name = self.__class__.__name__
#       print (class_name, "destroyed")

# pt1 = Point()
# pt2 = pt1
# pt3 = pt1
# print (id(pt1), id(pt2), id(pt3));   # печатает идентификаторы obejcts
# del pt1
# del pt2
# del pt3


# Classssessss

# class Person:
 
#     # конструктор
#     def __init__(self, name):
#         self.name = name  # устанавливаем имя
 
#     def display_info(self):
#         print("Привет, меня зовут", self.name)
 
 
# class Auto:
#     def __init__(self, name):
#         self.name = name
 
#     def move(self, speed):
#         print(self.name, "едет со скоростью", speed, "км/ч")


